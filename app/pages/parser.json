{
    "episodes": [
        {
            "title": "Parser",
            "description": "The Parser class converts tokens generated by the Lexer into a structured syntax tree. It checks token sequences, handles operations in order of precedence, and helps identify any errors in the source code.",
            "episode": [
                1,
                1
            ],
            "class_scope": "internal sealed",
            "changes": "",
            "constructors": [
                {
                    "scope": "public",
                    "description": "Sets up a Parser by processing tokens from the Lexer and collecting diagnostics.",
                    "delegated": [],
                    "body": "var tokens = new List<SyntaxToken>();\nvar lexer = new Lexer(text);\nSyntaxToken token;\ndo\n{\n\ttoken = lexer.NextToken();\n\tif (token.Kind != SyntaxKind.WhitespaceToken &&\n\t\ttoken.Kind != SyntaxKind.BadToken)\n\t{\n\t\ttokens.Add(token);\n\t}\n} while (token.Kind != SyntaxKind.EndOfFileToken);\n\n_tokens = tokens.ToArray();\n_diagnostics.AddRange(lexer.Diagnostics);",
                    "parameters": [
                        {
                            "name": "text",
                            "type": {
                                "type": "string",
                                "is_list": false,
                                "children": []
                            }
                        }
                    ]
                }
            ],
            "properties": [
                {
                    "scope": "private readonly",
                    "name": "_tokens",
                    "assignment": "",
                    "description": "Holds an array of tokens processed from the input text.",
                    "type": {
                        "type": "SyntaxToken",
                        "is_list": true,
                        "children": []
                    }
                },
                {
                    "scope": "private",
                    "name": "_diagnostics",
                    "assignment": "= new List<string>()",
                    "description": "Lists any parsing errors found during processing.",
                    "type": {
                        "type": "List",
                        "is_list": true,
                        "children": [
                            {
                                "type": "string",
                                "is_list": false,
                                "children": []
                            }
                        ]
                    }
                },
                {
                    "scope": "private",
                    "name": "_position",
                    "assignment": "",
                    "description": "Tracks the current token position.",
                    "type": {
                        "type": "int",
                        "is_list": false,
                        "children": []
                    }
                },
                {
                    "scope": "public",
                    "name": "Diagnostics",
                    "assignment": "=> _diagnostics",
                    "description": "Provides access to parsing errors.",
                    "type": {
                        "type": "IEnumerable",
                        "is_list": true,
                        "children": [
                            {
                                "type": "string",
                                "is_list": false,
                                "children": []
                            }
                        ]
                    }
                },
                {
                    "scope": "private",
                    "name": "Current",
                    "description": "Gets the current token.",
                    "assignment": "=> Peek(0);",
                    "type": {
                        "type": "SyntaxToken",
                        "is_list": false,
                        "children": []
                    }
                }
            ],
            "methods": [
                {
                    "scope": "private",
                    "signature": "Peek",
                    "description": "Gets the token at a given offset from the current position.",
                    "body": "var index = _position + offset;\nif (index >= _tokens.Length)\n\treturn _tokens[_tokens.Length - 1];\nreturn _tokens[index];",
                    "return_type": {
                        "type": "SyntaxToken",
                        "is_list": false,
                        "children": []
                    },
                    "parameters": [
                        {
                            "name": "offset",
                            "type": {
                                "type": "int",
                                "is_list": false,
                                "children": []
                            }
                        }
                    ]
                },
                {
                    "scope": "private",
                    "signature": "NextToken",
                    "description": "Moves to the next token and returns the current one.",
                    "body": "var current = Current;\n_position++;\nreturn current;",
                    "return_type": {
                        "type": "SyntaxToken",
                        "is_list": false,
                        "children": []
                    },
                    "parameters": []
                },
                {
                    "scope": "private",
                    "signature": "Match",
                    "description": "Checks if the current token matches the expected kind and adds an error if it doesn't.",
                    "body": "if (Current.Kind == kind)\n\treturn NextToken();\n\n_diagnostics.Add($\"ERROR: Unexpected token <{Current.Kind}>, expected <{kind}>\");\nreturn new SyntaxToken(kind, Current.Position, null, null);",
                    "return_type": {
                        "type": "SyntaxToken",
                        "is_list": false,
                        "children": []
                    },
                    "parameters": [
                        {
                            "name": "kind",
                            "type": {
                                "type": "SyntaxKind",
                                "is_list": false,
                                "children": []
                            }
                        }
                    ]
                },
                {
                    "scope": "private",
                    "signature": "ParseExpression",
                    "description": "Starts parsing by evaluating terms.",
                    "body": "ParseTerm();",
                    "return_type": {
                        "type": "ExpressionSyntax",
                        "is_list": false,
                        "children": []
                    },
                    "parameters": []
                },
                {
                    "scope": "public",
                    "signature": "Parse",
                    "description": "Begins parsing and confirms reaching the end of input.",
                    "body": "var expresion = ParseTerm();\nvar endOfFileToken = Match(SyntaxKind.EndOfFileToken);\nreturn new SyntaxTree(_diagnostics, expresion, endOfFileToken);",
                    "return_type": {
                        "type": "SyntaxTree",
                        "is_list": false,
                        "children": []
                    },
                    "parameters": []
                },
                {
                    "scope": "private",
                    "signature": "ParseTerm",
                    "description": "Parses terms, handling addition and subtraction.",
                    "body": "var left = ParseFactor();\n\nwhile (Current.Kind == SyntaxKind.PlusToken ||\n\t\tCurrent.Kind == SyntaxKind.MinusToken)\n{\n\tvar operatorToken = NextToken();\n\tvar right = ParseFactor();\n\tleft = new BinaryExpressionSyntax(left, operatorToken, right);\n}\nreturn left;",
                    "return_type": {
                        "type": "ExpressionSyntax",
                        "is_list": false,
                        "children": []
                    },
                    "parameters": []
                },
                {
                    "scope": "private",
                    "signature": "ParseFactor",
                    "description": "Parses factors, handling multiplication and division.",
                    "body": "var left = ParsePrimaryExpression();\n\nwhile (Current.Kind == SyntaxKind.StarToken ||\n\t\tCurrent.Kind == SyntaxKind.SlashToken)\n{\n\tvar operatorToken = NextToken();\n\tvar right = ParsePrimaryExpression();\n\tleft = new BinaryExpressionSyntax(left, operatorToken, right);\n}\nreturn left;",
                    "return_type": {
                        "type": "ExpressionSyntax",
                        "is_list": false,
                        "children": []
                    },
                    "parameters": []
                },
                {
                    "scope": "private",
                    "signature": "ParsePrimaryExpression",
                    "description": "Parses individual elements, such as numbers or expressions within parentheses.",
                    "body": "if (Current.Kind == SyntaxKind.OpenParenthesisToken)\n{\n\tvar left = NextToken();\n\tvar expression = ParseExpression();\n\tvar right = Match(SyntaxKind.CloseParenthesisToken);\n\treturn new ParenthesizedExpressionSyntax(left, expression, right);\n}\n\nvar numberToken = Match(SyntaxKind.NumberToken);\nreturn new NumberExpressionSyntax(numberToken);",
                    "return_type": {
                        "type": "ExpressionSyntax",
                        "is_list": false,
                        "children": []
                    },
                    "parameters": []
                }
            ]
        },
        {
            "title": "Parser",
            "description": "The Parser class converts tokens generated by the Lexer into a structured syntax tree. It checks token sequences, handles operations in order of precedence, and helps identify any errors in the source code.",
            "episode": [
                2,
                2
            ],
            "class_scope": "internal sealed",
            "changes": "",
            "constructors": [
                {
                    "scope": "public",
                    "description": "Sets up a Parser by processing tokens from the Lexer and collecting diagnostics.",
                    "delegated": [],
                    "body": "var tokens = new List<SyntaxToken>();\nvar lexer = new Lexer(text);\nSyntaxToken token;\ndo\n{\n\ttoken = lexer.Lex();\n\tif (token.Kind != SyntaxKind.WhitespaceToken &&\n\t\ttoken.Kind != SyntaxKind.BadToken)\n\t{\n\t\ttokens.Add(token);\n\t}\n} while (token.Kind != SyntaxKind.EndOfFileToken);\n\n_tokens = tokens.ToArray();\n_diagnostics.AddRange(lexer.Diagnostics);",
                    "parameters": [
                        {
                            "name": "text",
                            "type": {
                                "type": "string",
                                "is_list": false,
                                "children": []
                            }
                        }
                    ]
                }
            ],
            "properties": [
                {
                    "scope": "private readonly",
                    "name": "_tokens",
                    "assignment": "",
                    "description": "Holds an array of tokens processed from the input text.",
                    "type": {
                        "type": "SyntaxToken",
                        "is_list": true,
                        "children": []
                    }
                },
                {
                    "scope": "private",
                    "name": "_diagnostics",
                    "assignment": "= new List<string>()",
                    "description": "Lists any parsing errors found during processing.",
                    "type": {
                        "type": "List",
                        "is_list": true,
                        "children": [
                            {
                                "type": "string",
                                "is_list": false,
                                "children": []
                            }
                        ]
                    }
                },
                {
                    "scope": "private",
                    "name": "_position",
                    "assignment": "",
                    "description": "Tracks the current token position.",
                    "type": {
                        "type": "int",
                        "is_list": false,
                        "children": []
                    }
                },
                {
                    "scope": "public",
                    "name": "Diagnostics",
                    "assignment": "=> _diagnostics",
                    "description": "Provides access to parsing errors.",
                    "type": {
                        "type": "IEnumerable",
                        "is_list": true,
                        "children": [
                            {
                                "type": "string",
                                "is_list": false,
                                "children": []
                            }
                        ]
                    }
                },
                {
                    "scope": "private",
                    "name": "Current",
                    "description": "Gets the current token.",
                    "assignment": "=> Peek(0);",
                    "type": {
                        "type": "SyntaxToken",
                        "is_list": false,
                        "children": []
                    }
                }
            ],
            "methods": [
                {
                    "scope": "private",
                    "signature": "Peek",
                    "description": "Gets the token at a given offset from the current position.",
                    "body": "var index = _position + offset;\nif (index >= _tokens.Length)\n\treturn _tokens[_tokens.Length - 1];\nreturn _tokens[index];",
                    "return_type": {
                        "type": "SyntaxToken",
                        "is_list": false,
                        "children": []
                    },
                    "parameters": [
                        {
                            "name": "offset",
                            "type": {
                                "type": "int",
                                "is_list": false,
                                "children": []
                            }
                        }
                    ]
                },
                {
                    "scope": "private",
                    "signature": "NextToken",
                    "description": "Moves to the next token and returns the current one.",
                    "body": "var current = Current;\n_position++;\nreturn current;",
                    "return_type": {
                        "type": "SyntaxToken",
                        "is_list": false,
                        "children": []
                    },
                    "parameters": []
                },
                {
                    "scope": "private",
                    "signature": "MatchToken",
                    "description": "Checks if the current token matches the expected kind and adds an error if it doesn't.",
                    "body": "if (Current.Kind == kind)\n\treturn NextToken();\n\n_diagnostics.Add($\"ERROR: Unexpected token <{Current.Kind}>, expected <{kind}>\");\nreturn new SyntaxToken(kind, Current.Position, null, null);",
                    "return_type": {
                        "type": "SyntaxToken",
                        "is_list": false,
                        "children": []
                    },
                    "parameters": [
                        {
                            "name": "kind",
                            "type": {
                                "type": "SyntaxKind",
                                "is_list": false,
                                "children": []
                            }
                        }
                    ]
                },
                {
                    "scope": "private",
                    "signature": "ParseExpression",
                    "description": "Parses expressions while considering operator precedence.",
                    "body": "ExpressionSyntax left;\nvar unaryOperatorPrecedence = Current.Kind.GetUnaryOperatorPrecedence();\nif (unaryOperatorPrecedence != 0 && unaryOperatorPrecedence >= parentPrecedence)\n{\n\tvar operatorToken = NextToken();\n\tvar operand = ParseExpression(unaryOperatorPrecedence);\n\tleft = new UnaryExpressionSyntax(operatorToken, operand);\n}\nelse\n{\n\tleft = ParsePrimaryExpression();\n}\n\nwhile (true)\n{\n\tvar precedence = Current.Kind.GetBinaryOperatorPrecedence();\n\tif (precedence == 0 || precedence <= parentPrecedence)\n\t\tbreak;\n\tvar operatorToken = NextToken();\n\tvar right = ParseExpression(precedence);\n\tleft = new BinaryExpressionSyntax(left, operatorToken, right);\n}\n\nreturn left;",
                    "return_type": {
                        "type": "ExpressionSyntax",
                        "is_list": false,
                        "children": []
                    },
                    "parameters": [
                        {
                            "name": "parentPrecedence",
                            "type": {
                                "type": "int",
                                "is_list": false,
                                "children": []
                            }
                        }
                    ]
                },
                {
                    "scope": "public",
                    "signature": "Parse",
                    "description": "Begins parsing and confirms reaching the end of input.",
                    "body": "var expresion = ParseExpression();\nvar endOfFileToken = MatchToken(SyntaxKind.EndOfFileToken);\nreturn new SyntaxTree(_diagnostics, expresion, endOfFileToken);",
                    "return_type": {
                        "type": "SyntaxTree",
                        "is_list": false,
                        "children": []
                    },
                    "parameters": []
                },
                {
                    "scope": "private",
                    "signature": "ParsePrimaryExpression",
                    "description": "Parses individual elements, such as numbers or expressions within parentheses.",
                    "body": "switch (Current.Kind)\n{\n\tcase SyntaxKind.OpenParenthesisToken:\n\t{\n\t\tvar left = NextToken();\n\t\tvar expression = ParseExpression();\n\t\tvar right = MatchToken(SyntaxKind.CloseParenthesisToken);\n\t\treturn new ParenthesizedExpressionSyntax(left, expression, right);\n\t}\n\tcase SyntaxKind.FalseKeyword:\n\tcase SyntaxKind.TrueKeyword:\n\t{\n\t\tvar keywordToken = NextToken();\n\t\tvar value = keywordToken.Kind == SyntaxKind.TrueKeyword;\n\t\treturn new LiteralExpressionSyntax(keywordToken, value);\n\t}\n\tdefault:\n\t{\n\t\tvar numberToken = MatchToken(SyntaxKind.NumberToken);\n\t\treturn new LiteralExpressionSyntax(numberToken);\n\t}\n}",
                    "return_type": {
                        "type": "ExpressionSyntax",
                        "is_list": false,
                        "children": []
                    },
                    "parameters": []
                }
            ]
        },
        {
            "title": "Parser",
            "description": "The Parser class takes tokens generated by the Lexer and arranges them into a structured syntax tree. It verifies token sequences, manages operator precedence, and identifies errors in the source code.",
            "class_scope": "internal sealed",
            "changes": "Converted _diagnostics from List<string> to DiagnosticBag.\nTODO",
            "episode": [
                3, 30
            ],
            "constructors": [
                {
                    "scope": "public",
                    "description": "Initializes a new instance of the Parser class, lexes input text to generate tokens, and collects diagnostics from the Lexer.",
                    "delegated": [],
                    "parameters": [
                        {
                            "name": "text",
                            "type": {
                                "type": "string",
                                "is_list": false
                            }
                        }
                    ],
                    "body": "Lexes the input text and filters whitespace and bad tokens, then converts the list to an array and stores lexer diagnostics."
                }
            ],
            "properties": [
                {
                    "scope": "private readonly",
                    "name": "_tokens",
                    "description": "Stores an array of tokens processed from the input text.",
                    "type": {
                        "type": "SyntaxToken",
                        "is_list": true
                    }
                },
                {
                    "scope": "private",
                    "name": "_diagnostics",
                    "description": "Contains any diagnostics or errors detected during parsing.",
                    "type": {
                        "type": "DiagnosticBag",
                        "is_list": false
                    },
                    "assignment": "= new DiagnosticBag()"
                },
                {
                    "scope": "private",
                    "name": "_position",
                    "description": "Tracks the current position in the token array.",
                    "type": {
                        "type": "int",
                        "is_list": false
                    }
                },
                {
                    "scope": "public",
                    "name": "Diagnostics",
                    "description": "Provides access to diagnostics collected during parsing.",
                    "type": {
                        "type": "DiagnosticBag",
                        "is_list": false
                    },
                    "assignment": "=> _diagnostics"
                },
                {
                    "scope": "private",
                    "name": "Current",
                    "description": "Gets the current token without advancing the position.",
                    "type": {
                        "type": "SyntaxToken",
                        "is_list": false
                    },
                    "assignment": "=> Peek(0)"
                }
            ],
            "methods": [
                {
                    "scope": "private",
                    "signature": "Peek",
                    "description": "Retrieves the token at a specified offset from the current position, or the last token if out of bounds.",
                    "parameters": [
                        {
                            "name": "offset",
                            "type": {
                                "type": "int",
                                "is_list": false
                            }
                        }
                    ],
                    "return_type": {
                        "type": "SyntaxToken",
                        "is_list": false
                    },
                    "body": "Calculates the offset index and returns the token at that index if within bounds; otherwise, returns the last token."
                },
                {
                    "scope": "private",
                    "signature": "NextToken",
                    "description": "Advances the current position to the next token and returns the previous current token.",
                    "parameters": [],
                    "return_type": {
                        "type": "SyntaxToken",
                        "is_list": false
                    },
                    "body": "Stores the current token, advances the position, and returns the stored token."
                },
                {
                    "scope": "private",
                    "signature": "MatchToken",
                    "description": "Ensures the current token matches a specific kind, adding a diagnostic error if not, and returning the expected token kind.",
                    "parameters": [
                        {
                            "name": "kind",
                            "type": {
                                "type": "SyntaxKind",
                                "is_list": false
                            }
                        }
                    ],
                    "return_type": {
                        "type": "SyntaxToken",
                        "is_list": false
                    },
                    "body": "Compares the current token's kind with the expected kind, returning the token if they match or adding a diagnostic if they do not."
                },
                {
                    "scope": "public",
                    "signature": "Parse",
                    "description": "Begins parsing the token sequence, ensuring the end of file token is reached at the end.",
                    "parameters": [],
                    "return_type": {
                        "type": "SyntaxTree",
                        "is_list": false
                    },
                    "body": "Parses an expression, matches the end of file token, and returns a syntax tree with diagnostics, parsed expression, and end of file token."
                },
                {
                    "scope": "private",
                    "signature": "ParseExpression",
                    "description": "Initializes parsing of an expression with assignment handling.",
                    "parameters": [],
                    "return_type": {
                        "type": "ExpressionSyntax",
                        "is_list": false
                    },
                    "body": "Delegates parsing to ParseAssignmentExpression to handle potential assignment syntax."
                },
                {
                    "scope": "private",
                    "signature": "ParseAssignmentExpression",
                    "description": "Handles assignment expressions by checking for identifier-equals token pair and recursively parsing the right-hand expression.",
                    "parameters": [],
                    "return_type": {
                        "type": "ExpressionSyntax",
                        "is_list": false
                    },
                    "body": "If an identifier followed by an equals token is found, parses the assignment; otherwise, delegates to ParseBinaryExpression."
                },
                {
                    "scope": "private",
                    "signature": "ParseBinaryExpression",
                    "description": "Handles binary expressions, including operator precedence and recursion to maintain operator precedence order.",
                    "parameters": [
                        {
                            "name": "parentPrecedence",
                            "type": {
                                "type": "int",
                                "is_list": false
                            }
                        }
                    ],
                    "return_type": {
                        "type": "ExpressionSyntax",
                        "is_list": false
                    },
                    "body": "Parses unary and binary expressions, adjusting based on the precedence of operators to correctly group expressions."
                },
                {
                    "scope": "private",
                    "signature": "ParsePrimaryExpression",
                    "description": "Parses primary expressions including literals, identifiers, and parenthesized expressions.",
                    "parameters": [],
                    "return_type": {
                        "type": "ExpressionSyntax",
                        "is_list": false
                    },
                    "body": "Switches on token kinds to identify and return primary expressions like literals, identifiers, or parenthesized expressions."
                }
            ]
        }
    ]
}